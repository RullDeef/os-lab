## Лекция от 30.04.22

# ПРЕРЫВАНИЯ

В монолитном ядре все построено на прерываниях. принято выделять:
1. системные вызовы
2. исключения
3. аппаратные прерывания

Когда пишется interrupt, речь идет об аппаратных прерываниях. Основную часть составляют прерывания от устройств ввода-вывода, без них пользоваться системой невозможно, так как именно эти устройства предназначены для взаимодействия с пользователем. При этом аппаратные прерывания от внешних устройств возникают когда внешнее устройство завершило операцию ввода-вывода в соответствии с распараллеливанием функций в вычислительных системах.

Процессор не управляет внешними устройствами, ими управляют специальные устройства. В канальной архитектуре это каналы, в шинной -- контроллеры/адаптеры. Контроллеры входят в состав устройств ввода-вывода, адаптеры -- на материнской плате. Это программно управляемые устройства, они получают команду, она формируется драйвером устройства, эту команду он формирует когда у него имеется квант времени, поэтому часто говорят <<процессор посылает команду>>. Получив по шине данных команду контроллер устройства переходит к ее выполнению, процессор от управления внешним устройством отключается и переходит на выполнение другой работы. Процессор должен быть проинформирован о завершении процесса ввода-вывода, поскольку он управляет всей работой, выполняемой системой.

Для информирования процессора предназначены аппаратные прерывания. С течением времени их реализация претерпела изменения, но идея осталась. Она заключается в том, что процессор должен быть проинформирован о завершении операции. Поскольку процессор выполняет другую работу, она организована следующим образом: в цикле выполнения каждой команды процессор проверяет, пришло ли на его ножку прерывание, если сигнал прерывания пришел, то процессор переходит на обработку этого прерывания.

НА ЭКЗАМЕНЕ БУДУТ СПРАШИВАТЬ СНОВА(((( АДРЕСАЦИЯ ПРЕРЫВАНИЙ В ЗАЩИЩЕННОМ РЕЖИМЕ.

Итог такой адресации -- адресация обработчика прерывания, процессор переходит на выполнение соответствующего обработчика прерывания (handler'a)
Аппаратные прерывания выполняются на высочайшем уровне приоритета в ядре (<<ядреные коды>>). Обработчики прерываний являются одной из точек входа драйвера, один драйвер может иметь 1 обработчик прерывания. Обработчик прерывания выполняется на высочайшем уровне приоритета.

Весь код ядра винды выполняется на 0 уровне привилегий, дальше по IRQL, все аппаратные прерывания находятся выше DPC dispatch. В Unix/Linux у ядра числовой интервал приоритетов ядра, обработчики прерываний выполняются на самых высоких уровнях приоритета. В зависимости от системы это самые маленькие/самые большие -- декларация системы -- суть одна -- наивысший уровень приоритета. Уровень привилегий -- другое -- это кольца защиты, ядро на нулевом уровне, но в ядре имеются уровни приоритета. Когда выполняется аппаратное прерывание, никакая другая работа в системе выполняться не может, но SMP(symmetric multiprocessing)-архитектура внесла изменения (равноправные процессоры, работают с общей памятью). Поскольку несколько процессоров, которые выполняют работы параллельно, возникает следующая ситуация: тот процессор, который выполняет обработчик возникшего прерывания, на нем запрещены все прерывания, для остальных процессоров запрещены линии прерываний по этой линии IRQ (interrupt request). Это критическая ситуация для системы, поэтому обработчики апп прерываний должны завершаться как можно быстрее. Если они будут выполняться длительное время, на процессоре, который выполняет этот обработчик, никакая другая работа выполняться не будет, а остальные процессы не смогут реагировать на такие же прерывания -- сказывается на отзывчивости и быстродействии системы. Поэтому обработчики аппаратных прерываний выполняют минимально необходимый набор действий, например, такой обработчик прерывания для устройства ввода должен получить данные от устройства и поместить их в буфер ядра. Но процесс, который запрашивал ввод, он его запрашивал для того, чтобы получить данные, поэтому обработчики аппаратных прерываний делятся на 2 части:

1. Верхняя половина (top-half)
2. Нижняя половина (bottom-half)

Кроме сохранения пришедших данных в буфере ядра аппаратное прерывания, которым является top-half, также инициализирует выполнение т. н. <<отложенных действий>>, для того, чтобы система могла завершить обработку ввода-вывода.

3 типа нижней половины:
1. soft-IRQs (гибкие прерывания)
2. tasklet
3. workqueue (очереди работ)

<<Половины>> -- исторические названия, не меняются.

Обработчик прерывания является точкой входа драйвера (одной из), соответственно, любой драйвер может зарегистрировать в системе собственный обработчик, для этого используются специальные функции.

Основная библиотека ядра <linux/interrupt.h>

```C
typedef irqreturn_t (*irq_handler_t)(int, void *);
int	request_irq(unsigned int irq, void irq_handler_t handler, unsigned long flags, const char *name, void *dev);
```

У Цирюлика есть материал

В старых материалах не было типа `irq_return_t`, хэндлер определялся как `void`, 3ий параметр -- `struct pt_regs *` -- параметр, который демонстрировал регистры, сохраняемые в стеке при возникновении прерывания, при этом всегда следовала следующая фраза, что обычно с этими регистрами не стоит связываться, хотя их можно прочитать для того, чтобы определить, например, где и когда произошло прерывания: когда процесс выполнялся в режиме ядра или в режиме пользователя. В современных версиях это поле убрали.

Поскольку указан тип `typedef irqreturn_t` (библиотека irqreturn_t.h ?) мысль закончилась. <<мда>>. Определены:

```C
typedef int irqreturn_t;
#define IRQ_NONE (0)
#define IRQ_HANDLED (1)
#define IRQ_RETVAL (*) ((x) != 0)
```

Отсюда следует, что обработчик прерывания, результат его работы, может возвращать или `IRQ_NONE` или `IRQ_HANDLED`. Во многих примерах пишется `IRQ_NONE` в любом случае, но это неверно. Если прерывание обработано -- `IRQ_HANDLED`, если не удалось обработать -- `IRQ_NONE`.

Деление действий, связанных с обслуживанием работы устройств ввода-вывода на аппаратные прерывания и отложенные действия связано с уровнем приоритетов, на которых должны выполняться аппаратные прерывания, и необходимостью завершить обработку операции ввода-вывода и передать полученные данные, причем данные получаются в любом варианте, и когда проц запрашивает операцию ввода, и когда операцию, вывода, так как процесс получает информацию, выполнена операция или нет.

Но в ядре различаются 2 вида аппаратных прерываний: быстрые и медленные. В современных linux-системах к быстрым прерываниям относится только прерывание от системного таймера, все остальные -- медленные. Важно отметить, что в версии 2.6.19 все флаги, связанные с прерыванием были радикально изменены, изменилось даже их название. В старой версии флаги имели приставку SA, например, был флаг SA_INTERRUPT, который обозначал быстрые прерывания, SA заменена на IRQF, флаг заменен на IRQF_TIMER. 

Есть тонкие аппаратные понятия level_triggered и age_triggered (передний/задний фронты, и т. д.)

Прерывание, кроме обозначения большими буквами, имеет 16-ричное значение.

```C
#define IRQF_TIMER 0x00000200
```

Важнейшим для нашей работы является флаг

```C
#define IRQF_SHARED 0x00000080
```

Этот флаг устанавливается абонентами (теми, кто вызывает) для того, чтобы разрешить разделение линии IRQ разными устройствами (драйвер устройства, устройство выполняет операцию ввода/вывода, управляет им драйвер, соответственно, разные драйвера устройств могут быть заинтересованы в использовании одной и той же линии IRQ, поэтому существует `IRQF_SHARED`, даже 1 устройство может иметь несколько обработчиков прерываний (загружаемый модуль ядра) (клавы и тачпады ps/2)) Можно добавить новый обработчик прерывания, тогда <<родной>> и <<новый>> обработчики будут разделять одну и ту же линию IRQ.

Есть флаг 

```C
#define IRQF_PROBE_SHARED 0x0000100
```

Устанавливается в случае, если предполагается возможность наличия проблем при совместном использовании линии IRQ.

```C
#define IRQF_PERCPU 0x00000400
```

Флаги используются в сочетаниях. Данных предполагает, что обработчик прерывания будет закреплен (его выполнение) за определенным процессором (только он монопольно будет выполнять конкретный обработчик прерывания)

Линиями прерывания можно управлять, макросы управления линиями IRQ определены в `<linux/irqflags.h>`

* Для локального процессора: 

```C
_local_irq_disable()
_local_irq_enable()
```

* Для запрета одной линии прерывания:

```C
void disable_irq(unsigned int irq);
void disable_irq_nosync(unsigned int irq);
void enable_irq(unsigned int irq);
void synchronize_irq(unsigned int irq);
```

предназначена для ожидания завершения обработчика прерывания по линии IRQ, если он выполняется. Например, обработчик прерываний от сетевого адаптера копирует пришедший пакет в ядро, в ядре пакет ставится в буферную очередь, в которой ожидает обработки соответствующим потоком ядра.

В любом случае перед завершением обработчик аппаратного прерывания, который в нашем обсуждении называется top-half, инициализирует выполнение своей нижней половины -- отложенного действия -- bottom half.

После завершения выполнения обработчика аппаратного прерывания, когда выполнен return, завершается взаимодействие с контроллером прерываний, т.е код аппаратного прерывания выполнен, восстанавливаются локальные прерывания (разрешаются) на том процессоре, где выполнялся обработчик, восстанавливается старая маска прерываний (iret)
Прерывание от сетевого адаптера инициализирует выполнение отложенного действия и нижняя половина, инициализированная АП завершит обработку получения пакета, при этом смысл деления на верхнюю и нижнюю половину заключается в том, что нижняя выполняется при разрешенных прерываниях.

---

## SOFT IRQ (Гибкие прерывания)

В системе существует перечисление определенных в системе гибких прерываний в системе, которые определяются статически при компиляции ядра. В библиотеке <linux/interrupt.h> определена

```C
struct softirq_action {
	void (*action)(struct softirq_action *);
}
```

Которая содержит единственное поле action. Когда ядро выполняет обработчик отложенного прерывания типа softirq, функция `action` вызывается с указателем на структуру `softirq_action` в качестве параметра. Количество типов softirq определено в системе статически при компиляции.

В современных системах существует 10 обработчиков softirq имеет т. н. Индекс

| Индекс | Приоритет | Описание |
| --- | --- | --- |
| HI_SOFTIRQ | 0 | Высокоприоритетный softirq |
| TIMER_SOFTIRQ | 1 | таймеры |
| NET_TX_SOFTIRQ | 2 | Отправка сетевых пакетов |
| NET_TX_SOFTIRQ | 3 | Прием сетевых пакетов |
| BLOCK_SOFTIRQ | 4 | Блочные устройства (вторичная память) |
| BLOCK_IOPOLL_SOFTIRQ | 5 | опрос |
| TASKLET_SOFTIRQ | 6 | тасклеты |
| SHED_SOFTIRQ | 7 | планировщик |
| HRTIMER_SOFTIRQ | 8 | Не используется |
| RCU_SOFTIRQ | 9 | Должен быть последним |
| NR_SOFTIRQ | | число |

Все перечисленные имена softirq в системе представлены в следующем массиве:

```C
const char *const softirq_to_name[NR_SOFTIRQS] = {"HI", "TIMER", "NET_TX", "BLOCK", "BLOCK_IOPOLL", "TASKLET", "SHED", "HRTIMER", "RCU"};
```

Эту информацию можно увидеть в `/proc/softirqs`

Определена функция 

```C
void open_softirq(int nr, void (*action)(struct softirq_action *))
{
	softirq_vect[nr].action = action;
}
```

Которая заполняет вектор `softirq_vec` заданным типом `softirq_action`. Для того, чтобы зарегистрированное отложенное прерывание было поставлено в очередь на выполнение, необходимо вызвать функцию `void raise_softirq(unsigned int nr)`.

Везде подчеркивается, что добавить новый уровень `softirq` можно только путем перекомпиляции ядра, т. е. число обработчиков `softirq` не может быть изменено динамически, при этом смысл имеет только новое `softirq`, имеющее индекс на единицу меньше индекса `tasklet`, так как нет смысла переопределять количество `softirq`, так как можно использовать `tasklet`. Из перечисления видно, что `tasklet` является одним из типов `softirq`.

Функция `raise_softirq` с указанием конкретного индекса должна быть вызвана из обработчика аппаратного прерывания, он должен отметить конкретный `softirq` как то, которое должно быть поставлено в очередь на выполнение.

## Выполнение `softirq`

Проверка ожидающих выполнения обработчиков отложенных действий типа `softirq`, выполняется в следующих случаях:

1. При возврате из АП (аппаратное прерывание).
2. В контексте потока ядра `kernel softirq daemon` (`ksoftirqd`).
3. В любом коде ядра, в котором явно проверяются и запускаются ожидающие выполнения обработчики `softirq`, как это делается в сетевой подсистеме
отправка и получение сетевых пакетов `softirq`.

Независимо от способа выбора `softirq`, его выполнение осуществляется в функции `do_softirq()`. Она в цикле проверяет наличие отложенных прерываний, то есть каждый поток ядра `ksoftirqd` выполняет функцию `run_ksoftirqd()`, которая и проверяет наличие отложенных действий типа `softirq` и в зависимости от результата вызывает соответствующую функцию. Эти действия выполняются в цикле. 

Речь идет о сетевой карте (net core device). `net_dev_init` инициализирует прерывание `NET_RX_SOFTIRQ`, вызывая функцию `open_softirq()`.
