```C
struct inode_operations
{
    // ...
    int (*create)(struct inode*, struct dentry*, umode_t, bool);
    int (*mkdir)(struct inode*, struct dentry*, umode_t);
    int (*rmdir)(struct inode*, struct dentry*);
    int (*mknod)(struct inode*, struct dentry*, umode_t, dev_t);
    int (*rename)(struct inode*, struct dentry*, struct inode*, struct dentry*);
    // ...
    int (*atomic_open)(struct inode*, struct dentry*, struct file*, unsigned int open_flag, umode_t create_mode, int opened);
};
```

* `lookup` - данная функция выполняет поиск файлового индекса в указанном каталоге.
* `permission` - разрешение. Функция проверяет права доступа к указанному файлу, на который ссылается inode. Если доступ разрешен, то функция возвращает 0, иначе - отрицательное значение.
* поле `int_mask` - для большинства фс устанавл в NULL и в этом случае используется метод определенный в ВФС. Производится сравнение битовых полей режима доступа с указанной маской.
* `link` - жесткая ссылка.
* `symlink` - гибкая ссылка.
* `create` - вызывается системными вызовами `open(2)` и `create(2)`. Только в случае если вы вызываете `open` и `create` для обычного файла. При этом создается новый inode с указанным режимом доступа `mode`. И этот inode связан с элементом пути `dentry`. (@ Про параметр bool история умалчивает).
* `mkdir`/`rmdir` - создаем/удаляем директорию
* `mknod` - можно создать программный канал. Информация о созданном устройстве будет храниться в параметре dev_t.
* `atomic_open` - вызывается из `open`. При этом файл или создается или открывается одной неделимой операцией.

(@ Будет спец лаба, в которой мы будем углубляться в ядро, изучая системный вызов open).

Обращаем внимание на обращение к соответствующим полям inode_operations:

```C
struct inode
{
    // ...
    const struct inode_operations *i_op;
    // ...
};
```

Например, нам надо обратиться к функции `permission`:

```C
inode->iop->permission(inode, /* ... */);
```

---

Посмотрим доступ к определенному файлу по его имени. Для доступа к файлу необходимо получить его inode, потому что индекс inode'а является идентификатором файла. При этом необходимо понимать, что на самом деле для доступа к файлу его имя совсем не обязательно знать.

// lec8.drawio [page 1]

Рассмотрим еще один пример, как выполняется доступ к файлу.

`/usr/ast/mbox`

Начинаем с содержимого корневого каталога:

// lec8.drawio [page 2]

Копия индекса, которая находится в памяти (inode) содержит поля, которых нет в дисковом индексе: (забыла, что читала это на прошлой лекции).

---

## Dentry Object

Ясное изложение дано в книге Роберта Лава - "Операционная система Linux".

ВФС считает каждый каталог файлом, который содержит список других каталогов и файлов. Для работы с каталогами в Linux есть структура `struct dentry`. При этом ядро создает объект dentry для каждого компонента пути. Причем такой объект создается как говорят на лету, когда процесс обращается к файлу.

Объект dentry связывает компонент пути с соответствующим индексом (inode'ом). Например при поиске пути `/tmp/test` ядро создаст объект dentry для корневого каталога, затем создаст объект dentry для `tmp` корневого каталога, и третий объект dentry для `test`.

У объекта dentry нет соответствующего отображения на диске, то есть объект dentry не соотв какой-либо структуре данных на жестком диске (во вторичной памяти). ВФС создает эти объекты на лету, то есть в оперативной памяти, по строковому представлению имени пути. Поэтому структура, которая описывает элемент каталога struct dentry не имеет флагов для указания того, что объект был изменен. При работе с объектами dentry для ускорения доступа к ним они хранятся в так называемом SLAB-кэше, который называется `dentry_cache`. Отсюда следует, что объекты dentry создаются и уничтожаются путём вызова функций `kmem_cache_alloc()` и `kmem_cache_free()`.

Каждый объект dentry может находится в 1 из 4 состояний:

* `FREE` - в этом случае объект dentry не содержит достоверной инф и не исп ВФС. Соотв область памяти обрабатывается SLAB-распределителем.
* `UNUSED` - в этом состоянии объект dentry не используется ядром. Счетчик ипользования объекта dentry `d_count` равен 0, но поле `d_inode` по-прежнему указывает на связанный с ним inode. Такой объект dentry содержит достоверную информацию, но при необходимости его содержимое может быть удалено, чтобы освободить память.
* `ISUSED` - указывает, что в текущий момент времени объект используется ядром. Счетчик использования больше 0. Поле `d_inode` содержит указатель на связанный inode. Объект dentry содержит достоверную информацию и не может быть отброшен.
* `NEGATIVE` - inode связанный с dentry не существует. Или потому что соотв inode был удален с диска, или потому что объект dentry был создан путем разрешения пути к несуществующему файлу. В этом случае поле `d_inode` имеет значение `NULL`, но объект все еще находится в кэше dentry.

```C
struct dentry
{
    unsigned int d_flags;
    // ...
    struct hlist_bl_node d_hash; /* lookup hash list */
    struct dentry *d_parent;
    struct qstr d_name;
    struct inode *d_inode; /* where the name belongs to NULL is negative */
    const struct dentry_operations *d_op;
    struct super_block *d_sb;
    // ...
    union
    {
        struct list_head d_lru; /* LRU list */
        wait_queue_head_t *d_wait;
    };
    struct list_head d_child; // список подкаталогов родителя
    struct list_head d_subdirs; // подкаталоги текущего каталога
    // ...
};
```

Отрицательный inode часто называется противоречивым.

После того как ВФС прошла через этот путь, при этом выполнилось определение каждого элемента пути и этот жлемент пути преобразован в объект dentry, имеет смысл хранить в памяти объекты dentry которые мы рассматривали при прохождении конкретного пути. Удалять такие объекты крайне расточительно. Например часто пользователь редактирует какой-то файл и распечатывает или копирует, т.е. выполняет последовательность действий с одним и тем же файлом. Поэтому объекты dentry сохраняются в `dentry_cache`.

`dentry_cache` состоит из2 типов структур данных:

1. Набор объектов dentry в любом кроме FREE состоянии.
2. Хеш-таблица для быстрого обращения к объекту dentry связанного с заданным именем файла и заданным каталогом. Как правило, если требуемый объект не находится в кэше dentry, функция хеширования вернет 0.

Кэш dentry работает также как контроллер для кэша inode'ов. Inode'ы ядра, которые связаны с неиспользуемыми dentry не отбрасываются так как кэш dentry их еще использует. В результате они хранятся в памяти, что позволяет быстро на них ссылаться. Для описанных действий используется двусвязный список LRU.
