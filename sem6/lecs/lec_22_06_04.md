# Специальные файлы устройств

Специальные файлы устройств унифицируют доступ к периферийным устройствам. Эти фалы обеспечивают связь файловой системы и драйверов устройств. Такая интерпретация специальных файлов устройств обеспечивает доступ к внешним устройствам как к обычным файлам. Так же как и обычный файл, специальный файл устройства может быть открыт, закрыт, из него можно читать и в него можно писать.

Каждому внешнему устройству UNIX и Linux ставят в соответствие как минимум 1 специальный файл. Обычно эти файлы можно увидеть в каталоге `/dev` корневой файловой системы. Подкаталог `/dev/fd` содержит файлы с именами `0`, `1` и `2`. Но в некоторых системах имеются файлы с именами `/dev/stdin`, `/dev/stdout` и `/dev/stderr`.

Система поддерживает 2 типа специальных файлов устройств:

1. Символьный (не буферизуемый)
2. Блочный (буферизуемый)

В UNIX/Linux связь имени специального файла с устройством обеспечивает индексный дескриптор.

Взаимодействие прикладных программ с аппаратной частью компьютера под управлением ОС UNIX/Linux осуществляется по следющей схеме:

(page 1)

Драйвер это часть кода ядра, которая предназначена для управления конкретным устройством. Драйверы пишутся по правилам ОС, описываются точки входа.

Задача драйвера - управлять внешним устройством. Драйвер, кроме того, что он должен быть написан по жестким правилам написания в ОС, он должен преобразовывать данные, поступающие с/на устройство. Когда данные получаются, формат данных полученных от устройства должен быть преобразован в формат, понятный приложению, и наоборот - данные поступающие на устройство должны быть преобразованы в формат, понятный устройству.

В виндах определен так называемый стек драйверов, любое изменение функциональности системы реализуется с помощью драйверов.

**Только разработчик устройства может граммотно написать драйвер для этого устройства.**

---

В соответствии со сказанным (за исключением виндов), драйверы устройств в линукс бывают 3 типов:

1. **Встроенные драйверы**. Драйверы выполнение которых инициализируется при запуске системы. Примеры: VGA контроллер, контроллеры IDE, материнская плата, последовательные и параллельные порты.

2. **Реализованные как загружаемые модули ядра**. HID-драйвера (human interface driver): мышь, клава. Если вы пишете собственный HID драйвер мыши, то сначала надо выгрузить "родной" драйвер, и только после этого можно загрузить собственный, и он будет работать.SCSI-адаптеры, звуковые/сетевые карты. ФАйлы модулей ядра располагаются в `/lib/modules`. Обычно при инсталяции системы, задается перечень модулей, загружаемых на старте. `/etc/modules` - список этих модулей. В файле `/etc/modules.conf` находится перечень опций для таких модулей. (*Трогать грязными руками не рекомендуется* &copy; Рязанова) Для этого существуют специальные скрипты: `update-moduels` и др. Для подключения модулей в работающей системе имеются специальные команды: `lsmod`, `insmod`, `rmmod`, и также `modprobe` (автоматически загружает модули). Для того чтобы отобразить текущую конфигурацию всех модулей можно воспользоваться коммандой: `modprob -c`.

3. **Код поделен между ядром и специальной утилитой**. Например у драйвера принтера ядро отвечает за взаимодействие с параллельным портом (очень древние принтеры), а формирование управляющих сигналов для принтера осуществляет демон печати `lpd`, который для этих целей использует специальную программу-фильтр. Другим примером драйверов 3 типа являются драйвера модемов. Для идентификации специальных файлов устройств в системе имеется соответствующая система идентификации - это старший (или основной) и младший (или дополнительный) номера устройств (`major` and `minor` numbers). Очевидно что это общий подход к идентификации как символьных так и блочных устройств. В качестве примера возьмем символьное устройство (блочными устройствами являются внешние запоминающие устройства). Пример:

```bash
$ ls -l
crw-rw-rw- 1 root root  1,3 <data>  null
crw------- 1 root root 10,1 <data>  psaux
crw------- 1 root root  4,1 <data>  tty1
crw-rw-rw- 1 root tty  4,64 <data>  ttys0
            ...
crw-rw-rw- 1 root root  1,5 <data>  zero
```

Традиционно старший и младший номера идентифицируют драйвер, который связан с устройством. Пример: `/dev/null` и `/dev/zero` управляются драйвером 1, а виртуальные консоли и последовательные терминалы управляются драйвером 4. Современное ядро линукс позволяет разделять старшие номера. Но большинство устройств все ещё организованы по принципу "1 старший - 1 драйвер". Младшие номера используются ядром для определения конкретного устройства.

---

## Внутреннее представление номеров устройств.

В ядре существует тип `dev_t` (`<linux/types.h>`). Стандарт `POSIX.1` определяет существование данного типа, но не оговариает формат полей. Начиная с версии ядра 2.6.0 `dev_t` это 32 разрядно число, в котором 12 бит отведены для старшего номера и 20 для младшего.

Очевидно, что все это важно при написании собственного драйвера устрйоства. При этом следует помнить, что код драйвера должен просто передавать значения. Для этого необходимо использовать макросы из `<linux/kdev_t.h>`. Эти макросы позволяют получить старший и младший номера устройств:

```С
MAJOR(dev_t dev)
MINOR(dev_t dev)
```

Также возможно обратное действие. Если есть старший и младший номера устройств, а нужен `dev_t`, то используется макрос:

```С
MKDEV(int major, int minor)
```

Исходя из формата, начиная с ядра 2.6.0 система может поддерживать огромное число устройств.

// статья - repot Рязановой. Страшная тайна. Просьба - не выдавать

---

## Выделение и освобождение номеров устройств

Будем ориентироваться на символьные устройства.

Одно из первых действий, которые должен сделать драйвер, когда устанавливается символьное устройство - он должен получить 1 и более номеров устройств. Для того чтобы драйвер получил номера надо вызвать функцию:

```C
#include <linux/fs.h>
int register_chr_dev_region(dev_t first, unsigned int count, char *name);
```

`first` - номер устройства, начиная с которого необходимо выделить номера.

`count` - количество номеров устройств, которое запрашивается. Если `count` больше чем диапазон который запрашивается, может случится переход через диапазон. Все будет работать нормально пока будет доступен запрашиваемый диапазон номеров.

`name` - имя устройства, которое связывается с диапазоном номеров. Можно посмотреть в `proc/devices` и `sys/fs`.

При успешном выделении возвращается 0. отрицательное значение сигнализирует об ошибке.

Данная функция хорошо работает если заранее известно конкретное устройство, которому нужен номер. Однако часто не известно, какой старший номер использует устройство. Поэтому разработчики ядра особо подчеркивают, что для динамического выделения старшего номера надо использовать функцию:

```C
int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char* name);
```

В этой функции параметр `dev` только выходной. и он будет содержать первый номер в выделенном диапазоне при успешном завершении функции.

`firstminor` - первый запрошенный младший номер и обычно равен 0.

Несмотря на то, как выполняется распределение номеров устройств необходимо их освободить, когда они больше не используются. Для этого вызывается функция:

```C
void unregister_chrdev_region(dev_t first, unsigned int count);
```

Обычно эта функция вызывается в `exit` и `cleanup`.

---

## Динамическое выделение старшего номера

Некоторые старшие номера статически назначаются большинством устройств. Для просмотра уже используемых старших номеров, надо посмотреть `/proc/devides`. С помощью команды:

```bash
$ ls -l /dev/ | grep "^c"
```

можно посмотреть список символьных устройств.

| major | |
| --- | --- |
| 1 | ОЗУ |
| 2 | дисковод, гибкий диск |
| 3 | Первый контроллер IDE-дисков |
| 4 | Терминалы |
| 5 | Терминалы |
| 6 | принтер (паралл порт) |
| 8 | SCSI-диски |
| 13 | мышь |
| 14 | звук карты |

Следует помнить, что новые номера не присваиваются. В результате разработчик драйвера должен сделать выбор: просто подобрать номер, который кажется неиспользуемым, или выделить старшие номера динамически.

Разработчики ядра настоятельно рекомендуют использовать динамическое получение старших номеров устройств. То есть не следует брать случайным образом номер, из тех, которые кажутся свободными.

Но у динамического назначения номеров имеется недостаток, а именно - нельзя заранее создать узлы устройства, так как главный номер будет получен в последствии. Очевидно, что существуют рекомендации, одной из которых является следующая: при загрузке драйвера с динамическим назначением старшего номера вызов `insmod` следует заменить соответствующим скриптом, который после вызова `insmod` будет читать `/proc/devices`, чтобы создать специальный файл(-ы). Рекомендуется в скрипте использовать инструмент типа `awk`. Команда `awk` читает документ по строкам и выполняет указанные разработчиком действия, а результат выводит в `stdout`.

```bash
$ awk опции 'условие{действие}'
пример:

major=$(awk "\\$2= =\"$module\"{print\\$1}" /proc/devices)
```

В ядре имеется набор структур опредленных для работы со внешними устройствами. И основной базовой структурой является структура `struct device`. Это структура нижнего уровня. Поля инициализируются при подключении внешнего устройства.

```C
struct device
{
    struct device *parent; // устройство может не иметь родительского устройства (top level)

    // ...

    const char *init_name; // первоначальное имя устрйтсва
    
    // Очевидно что для любого устройства важно то, к какой шине оно подключается
    struct bus_type *bus; // bas?

    // ==========================
    struct device_driver *driver; // основная структура описывающая драйвер
    // ==========================

    // ...

    // интерсное поле (очень важная информация в архитектуре системы)
    struct dma_coherent_mem *dma_mem; // direct memory access - способ освобождения процессора от рутинной перекачки данных от устройства в оперативную память. coherent DMA mapping API. В этом случае нет необходимости выделять буфер DMA. Установка такого поля используется для устойчивого распределения многократно используемых буферов.

    // ...

    dev_t devt; // поле для создания в sys/fs девайсов
    u32 id; // т.н. экземпляр устройства
};
```

```C
struct device_driver
{
    const char *name;
    struct bus_type *bus;
    struct module *owner;
    // ...
    int (*probe)(struct device *dev);
    int (*remove)(struct device *dev);
    // ...
    int (*resume)(struct devicec *dev);
    // ...
};
```
