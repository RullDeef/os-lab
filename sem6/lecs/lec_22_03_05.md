
Начинается путь к файлу с корневого каталога, который обозначается `/`.

**Монтирование** - система действий, в резуль которой файловая система становится доступной.

Для монтирования файловой системы требуются права привелегированного пользователя.

Используется команда `mount`, которая имеет следующий общий синтаксис:

```bash
mount <ключи> -t <тип_фс> -o <опции_фс> <устройство> <каталог_назначения>
```

Соответственно, команда размонтирования - `umount`:

```bash
umount <ключи> -t <тип_фс> -o <опции_фс>
```

Кроме основной команды есть доп команды, в которых например может указыватся имя файловой системы, например `mount_nfs` (Network File System). Если подмонтирована файловая система виндов: `mount_ntfs`.

Можно сказать, что наиболее часто используется форма комманды `mount` с 2-мя параметрами: именем устройства или другого ресурса, который содержит монтируемую файловую систему и точку монтирования.

**Точка монтирования** - каталог, к которому подмонтируется файловая система.

Точка монтирования должна существовать, иначе возникнет ошибка (каталог должен существовать). Когда файловая система смонтирована в существующую директорию, все файлы и поддиректории этой смонтированной файловой системы становятся файлами и поддиректориями точки монтирования. Если директория точки монтирования содержала какие-либо файлы и поддиректории, то они не теряются, а становятся невидимыми.

Иногда может оказаться нужным явно указывать при монтировании тип файловой системы. Для этого используется опция `-t`. Это может возникнуть если осуществляется попытка подмонтировать какую-то новую файловую систему, имеющую новый тип, но поскольку Unix/Linux могут поддерживать большое количество файловых систем (т.е. могут поддерживать файловые системы разных типов), существует структура описывающая тип файловой системы.

Рассмотрим пример:

```bash
mount /dev/sda1 /mnt
```

Данная команда пробует монтировать раздел `sda1` с файловой системой `ext3` в каталог `/mnt` в режиме только чтения. Если в ОС нет библиотек для поддержки той или иной файловой системы или система в указанном разделе не является `ext3`, будет выдано сообщение о невозможности монтирования.

Если требуется включить режим записи, то необходимо добавить `-o rw`:

```bash
mount -o rw /dev/sda1 /mnt
```

* Структура `superblock` - предназначена для описания подмонтированных файловых систем. Именно она содержит всю необходимую информацию для обращения к файлам конкретной файловой системы.
* Структура `inode` - фактически дескриптор физического файла.
* Структура `dentry` - описывает элемент каталога и предназначена для доступа к файлам (этого каталога).
* Структура `file` - описывает открытый файл. При этом открытый файл - это файл который открыт каким-то процессом.

// @ для системы вы не существуете, как бы обидно это не звучало

// @ далее идет диаграмма с кокнцентрированной информацией

`inode` - 2 варианта (не копии). В ядре существуют структуры важные для действий в ядре. Мы видим, что `inode` существует в двух вариантах: дисковый и в ядре.

Нужна точка монтирования, нужен корневой каталог (файловой системы, которая монтируется).

Есть кеш `inode` и буферный кеш (кеш данных) ((@ в системе все буферизуется)). Кеши построены по принципу `LRU` (Last Recently Used). Поскольку они не могут быть любого нужного размера (ограничены возможностями физического хранения в ядре), по своему назначению - хранят данные, к которым были последние обращения.

Также здесь присутствует системная таблица открытых файлов. В этой системной таблице находятся дескрипторы всех открытых в системе файлов. Причем, если файл был открыт несколько раз, в этой таблице будет существовать соответствующее количество дескрипторов открытого файла, так как открытые файлы - это структура предназначенная для обслуживания процессов (процессы открывают файлы). При этом разные процессы могут открывать один и тот же файл. У этого файла может быть один и тот же `inode` ((@ существуют хардлинки - система не различает имена файлов (первое, воторое и тп.), все имена файлов для системы - это хардлинки)).

---

## Суперблок.

//@ очень большая схема. Частями эта схема существует в разных источниках, в частности в Стивене. Иметь в виду.

В данном примере мы рассмотрим раздел жесткого диска (раздел вторичной памяти) с файловой системой `ext2` (родная файловая система Linux).

**Блок** - минимальная адресуемая единица физического носителя (вторичной памяти). В разных системах размер блока может отличаться. Каждый блок имеет уникальный адрес. 

Любая файловая система предназначена для обеспечения долговременного хранения и доступа к файлам. Без доступа все это никому не нужно ((@ это же не клад, который вы зарыли и забыли где зарыли?)). Кроме того, что файловая система предназначена для хранения информации, в первую очередь она должна обеспечить доступ к этой информации. Этот доступ многоуровневый. Вторичная память - внешнее устройство. На каком-то последнем этапе мы обращаемся к этому устройству.

`inode`'ы описывают физический файл и они же (так называемые дисковые `inode`'ы) содержат информацию об адресах блоках вторичной памяти, в которой находится файл, который описывается конкретным `inode`'ом.

Очевидно, что суперблок должен содержать список `inode`'ов, но он должен содержать первый `inode` - `inode` корневого каталога (рута).

Файловая система `ext2` существует уже несколько лет (хорошо написана, является актуальной). Обеспечивает хранение и доступ к очень большим файлам.

По аналогии с физическим адресным пространством оперативной памяти, если первые операционные системы требовали, чтобы процессу было выделено непрерывное адресное пространство, и это оказалось невозможным при быстром росте ПО (прикладного). Такое требование в современных системах физически обеспечить невозможно. Не существует достаточно большого обьема физической памяти для обеспечения одновременной работы большого количества приложений с высокими требованиями к физической памяти, что характерно и для файлов. Размеры файлов также постоянно растут. Это было понято разработчиками Unix/Linux. Ими было предложено решение, когда файлу выделялось не непрерывное дисковое пространство, а была обеспечена возможность выделения свободных участков адресного пространства. В результате было обеспечено хранение и доступ к файлам очень большого размера.

Практически все источники приводят эту информацию о файловой системе `ext2` как наиболее яркий пример работы с файлами очень большого размера.

Видим, что суперблок хранит информацию о `inode`'ах, обеспечивает доступ к дисковому `inode`'у, а дисковый `inode` хранит информацию об адресах блоков вторичной памяти, в которых располагаются данные данного файла.

В этой файловой системе существует несколько *типов адресации* - прямая, косвенная, двойная косвенная и тройная косвенная.

Для адресации первых 12 блоков (0-11) используется прямая адресация. Соответственно это непосредственный адрес информационного блока. Следующие блоки содержат косвенные ссылки на другие блоки (inderect block), которые в свою очередь содержат адреса информационных блоков.

```C
struct super_block
{
    struct list_head s_list;
    dev_t s_dev;
    unsigned long s_blocksize;
    struct file_system_type *s_type;

    struct super_operations *s_op;

    unsigned long s_flags;
    unsigned long s_magic;
    struct dentry *s_root;
    struct rw_semaphore s_umount;

    // ...

    struct list_head s_mount;
    struct block_device *s_bdev;

    const struct dentry_operations *s_d_op;

    /* s_inode_list_lock protects s_inodes */
    spin_lock_t s_inode_list_lock;

    struct list_head s_inodes;

    // ...

    struct list_head s_inodes_wb;
};
```

Пояснения к некоторым полям:

* `struct list_head s_list`. Суперблоки объеденены в список. В системе будет существовать столько суперблоков, сколько смонтировано файловых систем. При этом может быть смонтировано несколько файловых систем одного и того же типа.

* `dev_t s_dev`. Очевидно, что смонтированная файловая система должна находиться на каком-то девайсе или на части ОС, на части адресного пространства оперативной памяти или на внешнем устройстве (это должен быть физический носитель).

* `unsigned long s_blocksize`. Важное значение имеет размер блока. Он является минимальной адресной единицей на вторичной памяти.

* `struct file_system_type *s_type`. Тип файловой системы - важнейшее понятие в Linux (так как Linux может поддерживать большое количество файловых систем). Структура `file_system_type` предназначена для регистрации типа конкретной файловой системы.

* `struct super_operations *s_op`. На суперблоке определён набор операций, которые с ним можно выполнять.

* `unsigned long s_flags`. Флаги для работы с файловой системой.

* `unsigned long s_magic`. Магическое число для обеспечения надежной работы.

* `struct dentry *s_root`. Указатель на рут.

* `struct rw_semaphore s_umount`. Очень интересное поле - семафоры чтения/записи. Работают по принципу читатели-писатели.

* `struct list_head s_inodes_wb` - (write back inodes). Cписок грязных `inode`'ов. Грязным файлом называется измененное значение.

В любой из перечисленных структур есть ссылка на операции, которые могут выполняться на этом суперблоке (фактически - ссылка на таблицу).

`dentry` является элементом пути к файлу. Каждый элемент пути имеет элемент `inode` и хранится на диске.

Каждая структура содержит средства взаимо-исключения. Список `inode`'ов должен защищаться, для этого используется спинлок.

Кроме этого есть список `inode`'ов. В этом списке находятся все `inode`'ы - дескрипторы физических файлов, созданных в конкретной файловой системе.

```C
struct super_operations
{
    struct inode *(*alloc_inode)(struct super_block *sb);
    void (*destroy_inode)(struct inode *);
    void (*free_inode)(struct inode *);
};
```

Очевидно, что поскольку любая файловая система предназначена для хранения физических данных, причем не просто данных, а поименнованных данных, мы видим, что это работа с `inode`'ом.

//@ продолжение следует ...
