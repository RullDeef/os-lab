struct dentry описывает элемент пути начиная с корневого каталога.

Например, еще раз: Обращение к файлу `/home/dracula/src/foo.c`

Каждый элемент каталога будет иметь inode (реальный inode). Эти элементы каталога с точки зрения структуры struct dentry создаются на-лету.

Очень показательным является момент:

```C
#include <linux/dcach.h>
```

При этом в этом кеше кешируются inode'ы, которые представляют элементы пути. Делается это для того, чтобы сократить время доступа к файлам. Кеширование строится на принципе LRU.

Очевидно, что пользователь не может ждать неопределенно долго. Время ответа системы не должно превышать 3 секунд.

```
Наука - свет, а неученых - тьма
@Рязанова
```

Кеш dentry состоит из 3 частей:

1. список обьектов dentry, которые связаны с определенным inode'ом. Поскольку один и тот же inode может иметь несколько ссылок соответствующих директориям, то это поле i_dentr структуры inode представлять из себя связанный список.

2. Двусвязный список неиспользуемых и противоречивых обьектов dentry. По алгоритму LRU. Очевидно, что добавление в этот список нового обьекта dentry должно выполняться по времени (по значению времени). Новый обьект записывается в хвост, удаление - из головы. Очевидно, что при работе с файлами нет диких (частых) обращений к файлам, поэтому алгоритм LRU может быть здесь использован.

3. Хеш-таблица и хеш-функция, которые позволяют преобразовывать заданный путь в обьект dentry. Эта таблица называется `dentry_hash_table`. Каждый элемент этой таблицы (а любая таблица это массив) является указателем на список тех обьектов dentry, которые соответствуют какому-то ключу. Значение ключа определяется функцией `d_hash()`, что позволяет для каждой файловой системы реализовать свою хеш-функцию. Поиск в хеш-таблице осуществляется функцией `d_lookup()`.

Приведенный пример как раз показывает, что сначала идёт поиск в dentry кеше, если поиск приводит к тому, что какого-то элемента каталога нет в кеше, то тогда идет обращение таким образом, который мы рассмотрели. В итоге найденный объект (его inode) будет помещен в кеш.

---

`struct dentry` имеет указатель на `struct dentry_operations`.

```C
struct dentry_operations
{
    // ...
    int (*d_hash)(const struct dentry *, struct qstr *);
    int (*d_compare)(const struct dentry *, const struct dentry *, unsigned int, const char *, const struct qstr *);
    int (*d_delete)(const struct dentry *);
    // ...
    struct vfsmount *(*d_automount)(struct path *);
    // ...
};
```

---

## inode кеш

```
С какого боку не возьми - упадёшь на inode
@Рязанова
```

Есть dentry кеш

```C
#include <linux/fs/inode.c> 
```

1. inode_hashtable - в котором каждый inode хешируется по значению указателя на суперблок и номеру inode'а. В случае отсутствия суперблока (то есть `inode->i_sb == NULL`) вместо хеш-массива, inode добавляется к двусвязному списку `anon_hash_chain`. Примерами таких анонимных inode'ов служат сокеты, которые создаются `sock_allock()` (библиотека `net/socket.c`), которая вызывает функцию `get_empty_inode()` из библиотеки `fs/inode.c`.

2. глобальный список `inode_in_use`, который содержит node'ы, у которых `i_count > 0 && i_nlink > 0`. inode'ы, которые создаются с помощью вызова функции `get_empty_inode()` и `get_new_inode()` добавляются в этот список.

3. Глобальный список `inode_unused`. Этот список содержит допустимые inode'ы (правильные), для которых `i_count == 0`.

4. Также для каждого суперблока свой `sb->s_dirty`. Имеется список грязных inode'ов. Это inode'ы, для которых `i_count > 0 && i_nlink > 0`, но они помеченные как модифицированные, то есть как `I_DIRTY`. Такой грязный node добавляется в список inode_idirty. ПОзволяет синхр-ть работу с inode'ами

5. SLAB кеш - (англ. брусок). `slab_cache` - `inode_cachep`. Этот подход был введен Джефом $\dots$ для ОС `Sun`. Идея SLAB кеша заключается в том, что в ядре значительные обьемы памяти выделятся на ограниченный набор обьектов, таких как дескрипторы файлов, inode'ы и тд. При этом для создания каждого такого обьекта. В результате для каждого такого обьекта выполняется выделение памяти. Когда обьект становится ненужным, происходит освобождение памяти. Причем это совершенно определенное ограниченное кол-во обьектов. При интенсивной работе системы постоянно создаются и постоянно освобождаются. -> трата времени на создание и удаление. Идея - не удалять обьекты из памяти, если на какое-то время нужда в этих обьектах отпала, при этом оставить в проинициализированном состоянии. Для того чтобы в последующем этот проинициализированный обьект использовать для других обьектов этого же типа.

Все перечисл списки защищены spin_lock'ом `inode_lock`.

---

## SLAB

главные структуры SLAB-распределителя. (материал Тима Джонса).

Виды slabs

* full - распределены полностью
* partial - частично
* empty - пустые (являются основными кандидатами на `reaping` - возврашения для дальнейшего использования)

Обьекты - основные элементы, которые выделяются из соотв кеша и возвращаются в него

При реализации slab'ов, участки памяти подходящие для размещения данных определенного типа и размера определяются заданее. Распределитель slab'ов - аллокатор (`alloc_slab`) хранит информацию о размещении этих участков, которые также известны как кеши. В результате, если возникает запрос на выделение памяти определенного размера, он удовлетворяется быстро.

```C
#include <linux/slab.h>
```

ВФС proc предоставляет информацию о slab кешах:

```Bash
$ cat /proc/slabinfo
slabinfo - version: 2.1
name            active_objs num_objs objsize objperslab pagesperslab ...
nf_conntrack         475    475    320   25    2
uvm_tools_event_tracker_t      0      0   1128   29    8
...
```

Для работы со SLAB кешами имеется набор функций:

```C
struct kmem_cache *kmem_cache_create(const char *name, size_t size, size_t offset, unsigned long flags, void (*ctor)(void *));
int kmem_cache_destroy(kmem_cache_t *cache);

void *kmem_cache_alloc(kmem_cache_t *cache, int flags);
void kmem_cache_free(kmem_cache_t *cache, const void *obj);
```

Про SLAB пишет Цирюлик: статья "SLAB'овый распределитель". (там есть большой пример)

---

## struct file

Эта структура описывает так называемые открытые файлы, то есть эта структура предоставляет инф-ю системе о файлах, которые были открыты процессами. Приэтом это одна единственная таблица, пользователю недоступная. Важнейшим моментом обьяснения ситуации с открытыми файлами является сам процесс открытия файлов. Для этого в различных структурах (даже в структурах ядра) имеются функции `open`.

```
Не то, откат
@Рязанова
```

```
Было? Или у вас на Питоне?



Несчастные... Без питона никуда
@Рязанова
```

```C
#include <fentl.h>

int open(const char *pathname, int oflag, ... /* mode_t mode */);

...

fd = open("myfile", O_RDWR|O_CREAT|O_EXCL, 0644);
```

Важный момент: константа `O_CREAT` предписывает если файл не существует, то необходимо его создать. И этот флаг требует в обязательном порядке наличия следующего аргумента - mode. И константа `O_EXCL` - ее указание делается для того, чтобы если файл уже существует, но задан флаг O_CREATE возникла ошибка. Такая комбинация флагов позволяет выполнять проверку существования файла и его создание атомарно.
